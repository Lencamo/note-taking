## 同源与跨域

&emsp;&emsp;如果两个 URL 的<span style="color:green;">协议、域名、端口</span>都一致，则他们<span style="color:red;">同源</span>，反之是跨域。

## 同源策略

&emsp;&emsp;出现跨域的根本原因：

> 浏览器的同源策略不允许非同源的 URL 之间进行资源的交互。

<img src="https://deer-sir.oss-cn-chengdu.aliyuncs.com/note-taking/20220611233328.png" width=575px />

## 一、JONSP 方式（前端解决）

&emsp;&emsp;由于浏览器的同源策略，网页<span style="color:green;">无法通过 ajax 请求非同源的接口数据</span>。但是：

> script 标签的 src 属性、img 标签的 src 属性、link 标签的 href 属性等是没有跨域的限制的。

### 原理：

&emsp;&emsp;动态添加一个\<script>标签，通过 src 属性请求跨域的数据接口，并通过函数调用的形式接受跨域接口响应回来的数据。

### 缺点：

&emsp;&emsp;只能解决 get 请求的跨域问题。

### ① 前端

- 原生 js 方式

```html
<body>
  <script>
    var scriptTag = document.createElement('script')
    // 可以自定义callback函数的函数名
    scriptTag.src = 'http://127.0.0.1:3000/api/list?callback=listBack'
    document.body.appendChild(scriptTag)

    function listBack(obj) {
      console.log(obj)
    }
  </script>
</body>
```

- jQuery 方式

```html
<body>
  <script src="./lib/jquery.min.js"></script>
  <script>
    $(function () {
      $.ajax({
        dataType: 'jsonp',
        url: 'http://127.0.0.1:3000/api/list',
        // 可以自定义🚩callback函数的函数名
        jsonp: 'callback',
        jsonpCallback: 'listBack',

        // 携带的参数
        data: {},

        success: function (res) {
          console.log(res)
        }
      })
    })
  </script>
</body>
```

### ② 后端

- Node.js 方式

```js
const http = require('http')
const url = require('url')

// 创建web服务器
http
  .createServer((req, res) => {
    // 获取前端定义的callback名称
    const urlobj = url.parse(req.url, true)

    callbackName = urlobj.query.callback
    // 根据前端的需求编写接口
    switch (urlobj.pathname) {
      case '/api/list':
        // 使用动态返回🚩的函数名
        res.end(
          `${callbackName}(${JSON.stringify({
            name: 'phone',
            price: 4999
          })})`
        )
        break
      default:
        res.end('404')
        break
    }
  })
  .listen(3000, '127.0.0.1', () => {
    console.log('Server running at http://127.0.0.1:3000')
  })
```

## 二、CORS 方式（后端解决）

### ① 前端

&emsp;&emsp;由于通过 CORS 的方式，后端已经解决了跨域问题，此时我们可以不用通过\<script>标签的 src 属性来调用接口。

> 此时直接使用 ajax 的方式就可以调用接口数据了，下面就使用常用的 axios 来请求数据吧。

- fetch 方式

```html
<body>
  <script>
    fetch('http://127.0.0.1:3000/api/list?id=1')
      // json格式化
      .then((res) => res.json())
      .then((res) => {
        //输出响应数据
        console.log(res)
      })
  </script>
</body>
```

- axios 方式

```html
<body>
  <script src="./lib/axios.min.js"></script>
  <script>
    async function axios_get() {
      const { data: res } = await axios({
        method: 'GET',
        url: 'http://127.0.0.1:3000/api/list',
        //get请求url中的查询参数 —— ✨params
        params: { id: 1 }
      })
      console.log(res)
    }

    axios_get()
  </script>
</body>
```

### ② 后端

- Node.js

```js
const http = require('http')
const url = require('url')

// 创建web服务器
http
  .createServer((req, res) => {
    // 获取前端定义的callback名称
    const urlobj = url.parse(req.url, true)

    callbackName = urlobj.query.callback

    res.writeHead(200, {
      'content-type': 'application',
      // 跨域问题解决方案：CORS🚩头
      'Access-Control-Allow-Origin': '*'
    })

    // 根据前端的需求编写接口
    switch (urlobj.pathname) {
      case '/api/list':
        // 直接✨返回JSON数据
        res.end(
          `(${JSON.stringify({
            name: 'phone',
            price: 4999
          })})`
        )
        break
      default:
        res.end('404')
        break
    }
    res.end()
  })
  .listen(3000, '127.0.0.1', () => {
    console.log('Server running at http://127.0.0.1:3000')
  })
```

## 三、express 中的跨域问题

1、安装 cors 中间件

> npm i cors -S

2、使用 cors 中间件

```JavaScript
const cors = require('cors')
app.use(cors())
```
